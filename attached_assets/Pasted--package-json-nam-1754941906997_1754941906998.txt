// ================================
// package.json
// ================================
{
  "name": "voice-intent-job-matcher",
  "version": "1.0.0",
  "description": "ìŒì„± ë¬¸ì¥ì„ ë¶„ì•¼ë¡œ ë§¤í•‘í•´ ëª¨ë“  ì—‘ì…€/CSVì—ì„œ ê³µê³ ë¥¼ í†µí•© ê²€ìƒ‰í•˜ê³ , 'ìˆ˜ë¦¬/ì •ë¹„' ì‹ í˜¸ë¥¼ ìš°ì„  ë°˜ì˜í•˜ëŠ” Replitìš© Node.js ì•±",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "NODE_ENV=development node server.js"
  },
  "dependencies": {
    "express": "^4.19.2",
    "xlsx": "^0.18.5"
  }
}

// ================================
// server.js
// ================================
const express = require('express');
const path = require('path');
const { loadAllData, getFields } = require('./src/data-loader');
const { extractIntent } = require('./src/intent');
const { scoreJob, buildMatcherForField } = require('./src/score');

const app = express();
const PORT = process.env.PORT || 3000;

// ì •ì  íŒŒì¼
app.use(express.static(path.join(__dirname, 'public')));

// ë°ì´í„° ì ì¬ (Replitì—ì„œëŠ” ./data í´ë”ì— .csv/.xls/.xlsx ë„£ì–´ë‘ì„¸ìš”)
const DATA_DIR = path.join(__dirname, 'data');
const { rows, fields, byField } = loadAllData(DATA_DIR);

app.get('/api/fields', (req, res) => {
  res.json({ fields: getFields(fields) });
});

// ê²€ìƒ‰ API: /api/search?text=...
app.get('/api/search', (req, res) => {
  const text = (req.query.text || '').toString();
  if (!text.trim()) {
    return res.json({ ok: true, intent: null, items: [] });
  }

  const intent = extractIntent(text, fields);

  // ê¸°ë³¸ í’€: ì „ì²´ â†’ topField ìˆìœ¼ë©´ í•´ë‹¹ ë¶„ì•¼ ìš°ì„  í’€ êµ¬ì„±
  let pool = rows;
  if (intent?.topField?.name) {
    const matcher = buildMatcherForField(intent.topField.name);
    const direct = (byField[intent.topField.name] || []).slice();
    const spillover = rows.filter(r => matcher(r.field) && r.field !== intent.topField.name);
    const seen = new Set();
    pool = [...direct, ...spillover].filter(r => {
      const key = r.__id;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  const scored = pool.map(item => ({ item, score: scoreJob(item, intent) }))
                     .sort((a, b) => b.score - a.score)
                     .slice(0, 30)
                     .map(({ item, score }) => ({ ...item, __score: score }));

  res.json({ ok: true, intent, items: scored });
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

// ================================
// src/data-loader.js
// ================================
const fs = require('fs');
const XLSX = require('xlsx');
const path2 = require('path');
const { synonymMap } = require('./keywordMap');

// ì»¬ëŸ¼ëª… í‘œì¤€í™” ë§¤í•‘ (í•œêµ­ì–´/ì˜ë¬¸/ë³€í˜• ì§€ì›)
const COLMAP = {
  company: ['íšŒì‚¬', 'íšŒì‚¬ëª…', 'ê¸°ì—…', 'ì—…ì²´', 'Company'],
  title: ['ì§ë¬´', 'ëª¨ì§‘ë¶€ë¬¸', 'í¬ì§€ì…˜', 'Title', 'ì±„ìš©í¬ì§€ì…˜'],
  field: ['ë¶„ì•¼', 'ì—…ì¢…', 'ì‚°ì—…', 'ì‚°ì—…ë¶„ë¥˜', 'ì‚°ì—…êµ°', 'Field', 'ì¹´í…Œê³ ë¦¬'],
  experience: ['ê²½ë ¥', 'ê²½ë ¥(ë…„)', 'ê²½ë ¥ì—°ìˆ˜', 'ê²½ë ¥ìš”ê±´', 'Experience'],
  education: ['í•™ë ¥', 'Education'],
  employment: ['ê³ ìš©í˜•íƒœ', 'í˜•íƒœ', 'Employment'],
  location: ['ì§€ì—­', 'ê·¼ë¬´ì§€', 'Location'],
  url: ['ë§í¬', 'URL', 'ê³µê³ ë§í¬', 'ì›ë¬¸', 'ApplyUrl'],
  deadline: ['ë§ˆê°ì¼', 'ì ‘ìˆ˜ë§ˆê°', 'Deadline'],
  desc: ['ì„¤ëª…', 'ì§ë¬´ì„¤ëª…', 'ì£¼ìš”ì—…ë¬´', 'Description']
};

function normalizeKey(k) {
  return (k || '').toString().trim().replace(/\s+/g, '').toLowerCase();
}

const aliasMap = (() => {
  const m = new Map();
  for (const std of Object.keys(COLMAP)) {
    for (const v of COLMAP[std]) {
      m.set(normalizeKey(v), std);
    }
  }
  return m;
})();

function mapColumns(row) {
  const out = {};
  for (const [k, v] of Object.entries(row)) {
    const std = aliasMap.get(normalizeKey(k));
    if (std) out[std] = v;
    else out[k] = v; // ì•Œ ìˆ˜ ì—†ëŠ” ì»¬ëŸ¼ì€ ë³´ì¡´
  }
  return out;
}

function readWorkbook(filePath) {
  const wb = XLSX.readFile(filePath, { cellDates: true });
  const first = wb.SheetNames[0];
  const ws = wb.Sheets[first];
  const json = XLSX.utils.sheet_to_json(ws, { defval: '' });
  return json.map(mapColumns);
}

function isExcelLike(name) {
  return /\.(csv|xlsx?|xls)$/i.test(name);
}

// ê°„ì´ í† í¬ë‚˜ì´ì €(í•œê¸€ íŠ¹ìˆ˜ë¬¸ì, ì , ì¤‘ì (Â·) ë“± ë¶„ë¦¬)
function tokenize(s) {
  return (s || '')
    .toString()
    .replace(/[\p{P}\p{S}]+/gu, ' ')
    .replace(/[Â·â€¢âˆ™]/g, ' ')
    .split(/\s+/)
    .map(t => t.trim())
    .filter(t => t.length >= 1);
}

const STOP = new Set(['ë°', 'ë“±', 'ê¸°íƒ€', 'ì¼ë°˜', 'ë‹´ë‹¹', 'ê´€ë¦¬', 'ìš´ì˜', 'ì—…ë¬´', 'ë¶€', 'íŒ€', 'ë¶€ì„œ', 'ì±„ìš©']);

function learnFromFieldString(fieldStr, stdField) {
  const bag = tokenize(fieldStr);
  const syn = new Set(synonymMap[stdField] || []);
  for (const t of bag) {
    if (STOP.has(t)) continue;
    if (!syn.has(t)) syn.add(t);
  }
  synonymMap[stdField] = Array.from(syn);
}

function loadAllData(dir) {
  const files = fs.existsSync(dir) ? fs.readdirSync(dir) : [];
  const rows = [];
  const fields = new Map(); // name -> count
  const byField = {}; // name -> rows

  let autoId = 1;
  for (const fname of files) {
    if (!isExcelLike(fname)) continue;
    const full = path2.join(dir, fname);
    let arr = [];
    try {
      arr = readWorkbook(full);
    } catch (e) {
      console.error('íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:', full, e.message);
      continue;
    }

    for (const r of arr) {
      const fieldName = (r.field || '').toString().trim() || 'ë¯¸ë¶„ë¥˜';
      // ê°„ì´ í•™ìŠµ: ë¶„ì•¼ ë¬¸ìì—´ì„ ë™ì˜ì–´ì— ìë™ ì¶”ê°€
      learnFromFieldString(fieldName, fieldName);

      const item = {
        __id: `${fname}#${autoId++}`,
        sourceFile: fname,
        company: r.company || '',
        title: r.title || '',
        field: fieldName,
        experience: r.experience || '',
        education: r.education || '',
        employment: r.employment || '',
        location: r.location || '',
        url: r.url || '',
        deadline: r.deadline || '',
        desc: r.desc || ''
      };
      rows.push(item);
      const key = item.field;
      fields.set(key, (fields.get(key) || 0) + 1);
      if (!byField[key]) byField[key] = [];
      byField[key].push(item);
    }
  }

  // ë°ì´í„°ì—ì„œ íŒŒìƒëœ ë¶„ì•¼ëª…ì´ ì‹œë“œì— ì—†ìœ¼ë©´ ë“±ë¡
  for (const f of fields.keys()) {
    if (!synonymMap[f]) synonymMap[f] = [];
  }

  return { rows, fields, byField };
}

function getFields(fieldsMap) {
  return Array.from(fieldsMap.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([name, count]) => ({ name, count }));
}

module.exports = { loadAllData, getFields };

// ================================
// src/keywordMap.js
// ================================
// ë¶„ì•¼ë³„ ë™ì˜ì–´/ì—°ê´€í‚¤ì›Œë“œ ì‹œë“œ (í•„ìš”ì‹œ ììœ ë¡­ê²Œ ë³´ê°•)
const synonymMap = {
  'ë§ˆì¼€íŒ…': ['ë§ˆì¼€íŒ…', 'ê´‘ê³ ', 'ë¸Œëœë”©', 'í”„ë¡œëª¨ì…˜', 'ìº í˜ì¸', 'í¼í¬ë¨¼ìŠ¤', 'ë””ì§€í„¸', 'ì½˜í…ì¸ ', 'sns', 'ë§ˆì¼€í„°','í™ë³´','ê²½ì˜','ê¸°íš','ì˜ì—…','MD'],
  'ì œì¡°ì—…': ['ì œì¡°','ë„¤íŠ¸ì›Œí¬','IT','ì›¹í”„ë¡œê·¸ë¨','ì „ì', 'ì†Œí”„íŠ¸ì›¨ì–´','ìƒì‚°', 'ê³µì •', 'ì„¤ë¹„', 'ë³´ì „', 'í’ˆì§ˆ', 'qaqc', 'ì›ê°€', 'ìì¬', 'ë¼ì¸', 'í˜„ì¥', 'ìˆ˜ë¦¬', 'ì •ë¹„', 'ìœ ì§€ë³´ìˆ˜', 'ë³´ìˆ˜', 'a/s', 'as', 'maintenance', 'repair', 'ì„œë¹„ìŠ¤','ì „ì‚°'],
  'ì •ë³´í†µì‹ ì—…': ['it', 'ë¹…ë°ì´í„°','ì¸ê³µì§€ëŠ¥','ë°ì´í„°ë² ì´ìŠ¤','ì •ë³´í†µì‹ ', 'ê°œë°œ', 'ë°±ì—”ë“œ', 'í”„ë¡ íŠ¸', 'ë„¤íŠ¸ì›Œí¬', 'ë³´ì•ˆ', 'ë°ì´í„°', 'ëª¨ë°”ì¼', 'ì„œë²„', 'si', 'pm', 'qa', 'í—¬í”„ë°ìŠ¤í¬', 'itì§€ì›', 'ì¥ë¹„ìˆ˜ë¦¬', 'ì¥ë¹„ ìœ ì§€ë³´ìˆ˜'],
  'ìš´ìˆ˜ ë° ì°½ê³ ì—…': ['ìš´ìˆ˜', 'ìš´ì†¡', 'ë¬¼ë¥˜', 'ì°½ê³ ', '3pl', 'wms', 'ì¬ê³ ', 'í¬ì›Œë”©', 'íƒë°°', 'í„°ë¯¸ë„', 'ë°°ì†¡', 'ì¥ë¹„ì •ë¹„', 'ì§€ê²Œì°¨ì •ë¹„','MD','HRM','íŒ¨ì…˜','ì˜ì—…'],
  'ê±´ì„¤ì—…': ['ê±´ì„¤', 'ì‹œê³µ', 'í† ëª©', 'ê¸°ê³„','ê±´ì¶•', 'ì•ˆì „', 'í’ˆì§ˆ', 'ì „ê¸°', 'ê²¬ì ', 'ì›ê°€', 'í˜„ì¥ì†Œì¥', 'ìœ ì§€ë³´ìˆ˜','ì¸í…Œë¦¬ì–´','ì‹œì„¤','ì„¤ê³„','ì£¼íƒê´€ë¦¬','í˜„ì¥','ì¡°ê²½'],
  'ê³¼í•™ ê¸°ìˆ  ì„œë¹„ìŠ¤ì—…': ['ê³¼í•™ê¸°ìˆ ', 'r&d', 'ì—°êµ¬', 'ì‹¤í—˜', 'ë¶„ì„', 'ì»¨ì„¤íŒ…', 'íŠ¹í—ˆ', 'ê¸°ìˆ ì´ì „', 'ê²€êµì •', 'ì¥ë¹„ìœ ì§€ë³´ìˆ˜','í™”í•™'],
  'ì˜ë£Œ': ['ì˜ë£Œ', 'ë³‘ì›', 'ê°„í˜¸', 'ì›ë¬´', 'crc', 'ì„ìƒ', 'ì˜ë£Œê¸°ê¸°', 'ì˜ì‚¬', 'ê°„í˜¸ì¡°ë¬´ì‚¬','ì•½ë¬´','ë°”ì´ì˜¤','ë³´ê±´'],
  'ì˜ˆìˆ ': ['ì˜ˆìˆ ', 'ì „ì‹œ', 'ê³µì—°', 'ë¬´ëŒ€', 'ë””ìì¸', 'ì˜ìƒ', 'ì‚¬ì§„', 'ë¸Œëœë”©', 'í¸ì§‘', 'ì•„íŠ¸','ì¶œíŒ','ë°©ì†¡ì œì‘','ìŠ¤í¬ì¸ '],
  'ì„œë¹„ìŠ¤ì—…': ['í˜¸í…”','ìš”ë¦¬','ìˆ™ë°•','ë ˆìŠ¤í† ë‘', 'ì‹ìŒë£Œ', 'ì—¬í–‰', 'ê´€ê´‘', 'ë¯¸ìš©', 'í—¤ì–´', 'í”¼ë¶€ê´€ë¦¬', 'ë§ˆì‚¬ì§€', 'ì„¸íƒ', 'ì²­ì†Œ','ê³ ê°ìƒë‹´','ì½œì„¼í„°','CS'],
};

// ë¶„ì•¼ í‘œì‹œëª…ì´ íŒŒì¼ë§ˆë‹¤ ë‹¤ë¥´ë©´ ì´ í‘œì¤€ ë¼ë²¨ë¡œ ë§µí•‘í•˜ì„¸ìš”
const fieldAlias = {
  'í˜¸í…”,ìš”ë¦¬ ë° ìˆ™ë°• ì„œë¹„ìŠ¤ì—…': 'ì„œë¹„ìŠ¤ì—…',
  'ì •ë³´í†µì‹ ': 'ì •ë³´í†µì‹ ì—…',
  'ì •ë³´í†µì‹ ì—…(IT)': 'ì •ë³´í†µì‹ ì—…',
  'ìš´ìˆ˜Â·ì°½ê³ ': 'ìš´ìˆ˜ ë° ì°½ê³ ì—…',
  'ìš´ìˆ˜/ì°½ê³ ': 'ìš´ìˆ˜ ë° ì°½ê³ ì—…',
  'ë§ˆì¼€íŒ…/ê´‘ê³ ': 'ë§ˆì¼€íŒ…'
};

module.exports = { synonymMap, fieldAlias };

// ================================
// src/intent.js
// ================================
const { synonymMap, fieldAlias } = require('./keywordMap');

function normalizeText(s) {
  return (s || '')
    .toString()
    .replace(/[\p{P}\p{S}]+/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function extractYears(s) {
  const m = s.match(/(\d+)\s*ë…„/g);
  if (!m) return null;
  const nums = m.map(x => parseInt(x.replace(/[^0-9]/g, ''), 10)).filter(n => !isNaN(n));
  if (!nums.length) return null;
  return Math.max(...nums);
}

function canonicalFieldName(name) {
  if (!name) return name;
  return fieldAlias[name] || name;
}

const REPAIR_TOKENS = ['ìˆ˜ë¦¬', 'ì •ë¹„', 'ìœ ì§€ë³´ìˆ˜', 'ë³´ìˆ˜', 'a/s', 'as', 'ì—ì´ì—ìŠ¤', 'maintenance', 'repair', 'ì„œë¹„ìŠ¤', 'ê³ ì¥', 'ì¥ë¹„ìˆ˜ë¦¬'];

function extractIntent(text, fieldsMap) {
  const raw = normalizeText(text);
  const lower = raw.toLowerCase();
  const years = extractYears(raw);

  const candidates = [];
  const fields = Array.from(fieldsMap?.keys?.() || []);

  const addScore = (map, key, by = 1) => {
    map[key] = (map[key] || 0) + by;
  };

  const scoreMap = {};

  // 1) í‘œì¤€ ë¶„ì•¼ëª… ì§ì ‘ ì¼ì¹˜
  for (const f of fields) {
    const cf = canonicalFieldName(f);
    if (!cf) continue;
    if (raw.includes(cf)) addScore(scoreMap, cf, 3);
  }

  // 2) ë™ì˜ì–´/ì—°ê´€ì–´ ë¶€ë¶„ì¼ì¹˜
  for (const [f, syns] of Object.entries(synonymMap)) {
    const cf = canonicalFieldName(f);
    for (const term of syns) {
      if (!term) continue;
      if (lower.includes(String(term).toLowerCase())) addScore(scoreMap, cf, 1);
    }
  }

  // 3) "ìˆ˜ë¦¬/ì •ë¹„" ë¥˜ ì‹ í˜¸ê°€ ìˆìœ¼ë©´, ê·¸ í‚¤ì›Œë“œë¥¼ ë™ì˜ì–´ë¡œ ê°€ì§„ ë¶„ì•¼ë“¤ì„ ê°€ì‚°
  const hasRepairHint = REPAIR_TOKENS.some(t => lower.includes(t.toLowerCase()));
  if (hasRepairHint) {
    for (const [f, syns] of Object.entries(synonymMap)) {
      if (syns.some(s => REPAIR_TOKENS.includes(String(s).toLowerCase()))) {
        addScore(scoreMap, canonicalFieldName(f), 2);
      }
    }
  }

  // 4) ë£° íŒíŠ¸(ë¶€ì„œ/íŒ€/ì§ë¬´ íŒ¨í„´)
  const ruleHints = [
    { re: /(ë§ˆì¼€íŒ…|ê´‘ê³ |ë¸Œëœë”©|í¼í¬ë¨¼ìŠ¤|crm)/i, f: 'ë§ˆì¼€íŒ…', w: 2 },
    { re: /(ìƒì‚°|ê³µì •|í’ˆì§ˆ|ì„¤ë¹„|ë³´ì „|ê¸°ê³„|ìˆ˜ë¦¬|ê¸ˆì†|ì„¬ìœ |í™”í•™|í™˜ê²½)/i, f: 'ì œì¡°ì—…', w: 2 },
    { re: /(ê°œë°œ|ì„œë²„|ë„¤íŠ¸ì›Œí¬|ë³´ì•ˆ|ë°ì´í„°|it|ì•±|ì›¹)/i, f: 'ì •ë³´í†µì‹ ì—…', w: 2 },
    { re: /(ë¬¼ë¥˜|ì°½ê³ |wms|ìš´ì†¡|ë°°ì†¡|í¬ì›Œë”©|íƒë°°)/i, f: 'ìš´ìˆ˜ ë° ì°½ê³ ì—…', w: 2 },
    { re: /(ê±´ì„¤|ì‹œê³µ|í† ëª©|ê±´ì¶•|ì•ˆì „|ê²¬ì |ì „ê¸°ì„¤ë¹„)/i, f: 'ê±´ì„¤ì—…', w: 2 },
    { re: /(r&d|ì—°êµ¬|ì‹¤í—˜|ë¶„ì„|íŠ¹í—ˆ|ì»¨ì„¤íŒ…)/i, f: 'ê³¼í•™ ê¸°ìˆ  ì„œë¹„ìŠ¤ì—…', w: 2 },
    { re: /(ë³‘ì›|ê°„í˜¸|ì„ìƒ|ì›ë¬´|ì˜ë£Œê¸°ê¸°)/i, f: 'ì˜ë£Œ', w: 2 },
    { re: /(ì „ì‹œ|ê³µì—°|ë””ìì¸|ì˜ìƒ|ì‚¬ì§„|ë¸Œëœë”©)/i, f: 'ì˜ˆìˆ ', w: 2 },
    { re: /(ì „ê¸°|ê°€ìŠ¤|ì¦ê¸°|ê³µì¡°|ë°°ì „|ë³€ì „|ë‚œë°©|ì—ë„ˆì§€)/i, f: 'ê³µê¸‰ì—…', w: 2 },
    { re: /(ìˆ˜ë¦¬|ì •ë¹„|ìœ ì§€ë³´ìˆ˜|ë³´ìˆ˜|a\/s|maintenance|repair)/i, f: 'ì œì¡°ì—…', w: 3 }
  ];
  for (const r of ruleHints) {
    if (r.re.test(raw)) addScore(scoreMap, r.f, r.w);
  }

  for (const [name, score] of Object.entries(scoreMap)) {
    if (!score) continue;
    candidates.push({ name, score });
  }

  candidates.sort((a, b) => b.score - a.score);
  const topField = candidates[0] || null;

  return {
    raw,
    years,
    candidates,
    topField
  };
}

module.exports = { extractIntent };

// ================================
// src/score.js
// ================================
const { synonymMap } = require('./keywordMap');

function buildMatcherForField(fieldName) {
  const syns = new Set([fieldName, ...(synonymMap[fieldName] || [])]);
  return (value) => {
    const s = (value || '').toString().toLowerCase();
    for (const t of syns) {
      if (!t) continue;
      if (s.includes(String(t).toLowerCase())) return true;
    }
    return false;
  };
}

const REPAIR_TOKENS = ['ìˆ˜ë¦¬', 'ì •ë¹„', 'ìœ ì§€ë³´ìˆ˜', 'ë³´ìˆ˜', 'a/s', 'as', 'ì—ì´ì—ìŠ¤', 'maintenance', 'repair', 'ì„œë¹„ìŠ¤', 'ê³ ì¥', 'ì¥ë¹„ìˆ˜ë¦¬'];

function hasAnyToken(text, tokens) {
  const s = (text || '').toString().toLowerCase();
  return tokens.some(t => s.includes(String(t).toLowerCase()));
}

function scoreJob(item, intent) {
  let score = 0;
  const query = (intent?.raw || '').toLowerCase();
  const topField = intent?.topField?.name || null;

  // 1) ë¶„ì•¼ ì •í™•ë„
  if (topField) {
    if ((item.field || '').toString() === topField) score += 10; // ê°™ì€ ë¶„ì•¼ ìµœìš°ì„ 
    else if (hasAnyToken(item.field, [topField])) score += 6; // ë¶€ë¶„ ì¼ì¹˜
  }

  // 2) ìˆ˜ë¦¬/ì •ë¹„ í‚¤ì›Œë“œ: ë¶„ì•¼/ì œëª©/ì„¤ëª…ì— ìˆì„ ë•Œ ê°€ì‚° (ì‚¬ìš©ì ë¬¸ì¥ì— ìˆ˜ë¦¬ë¥˜ ì‹ í˜¸ê°€ ìˆì„ìˆ˜ë¡ ë” ê°€ì‚°)
  const userWantsRepair = hasAnyToken(query, REPAIR_TOKENS);
  if (userWantsRepair) {
    if (hasAnyToken(item.field, REPAIR_TOKENS)) score += 8; // ë¶„ì•¼ì— ë°”ë¡œ í‘œì‹œ
    if (hasAnyToken(item.title, REPAIR_TOKENS)) score += 4;
    if (hasAnyToken(item.desc, REPAIR_TOKENS)) score += 3;
  } else {
    // ì‚¬ìš©ì ë¬¸ì¥ì— ìˆ˜ë¦¬ ì‹ í˜¸ ì—†ë”ë¼ë„, ê³µê³ ì— ìˆìœ¼ë©´ ì•½í•œ ë³´ë„ˆìŠ¤
    if (hasAnyToken(item.field, REPAIR_TOKENS)) score += 3;
  }

  // 3) ë™ì˜ì–´ ë§¤ì¹­ (ì‚¬ìš©ì ë¬¸ì¥ â†” í•´ë‹¹ ë¶„ì•¼ ë™ì˜ì–´)
  const fSyns = synonymMap[item.field] || [];
  for (const term of fSyns) {
    if (!term) continue;
    if (query.includes(String(term).toLowerCase())) score += 1;
  }

  // 4) ê¸°íƒ€ íœ´ë¦¬ìŠ¤í‹±: ì œëª©/ì„¤ëª…ì— ë¶„ì•¼ëª… í¬í•¨
  if (hasAnyToken(item.title, [item.field])) score += 1;
  if (hasAnyToken(item.desc, [item.field])) score += 1;

  return score;
}

module.exports = { buildMatcherForField, scoreJob };

// ================================
// public/index.html
// ================================
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ìŒì„± ê¸°ë°˜ ë¶„ì•¼ ë§¤ì¹­</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    .row { display: flex; gap: 12px; align-items: center; }
    textarea { width: 100%; height: 80px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; font-size: 14px; }
    th { background: #f7f7f7; }
    .score { font-variant-numeric: tabular-nums; color: #444; }
  </style>
</head>
<body>
  <h1>ìŒì„± ê¸°ë°˜ ë¶„ì•¼ ë§¤ì¹­</h1>
  <div class="row">
    <button id="btnMic">ğŸ™ï¸ ìŒì„± ì…ë ¥</button>
    <button id="btnSearch">ê²€ìƒ‰</button>
  </div>
  <textarea id="q" placeholder="ì˜ˆ) ë‚˜ëŠ” ì‚¼ì„±ì—ì„œ ê¸°ê³„ ìˆ˜ë¦¬ ì¼ì„ í–ˆë‹¤"></textarea>
  <div id="intent"></div>
  <table id="tbl">
    <thead>
      <tr>
        <th>ì ìˆ˜</th>
        <th>íšŒì‚¬</th>
        <th>ì§ë¬´</th>
        <th>ë¶„ì•¼</th>
        <th>ì§€ì—­</th>
        <th>ë§í¬</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <script src="/app.js"></script>
</body>
</html>

// ================================
// public/app.js
// ================================
async function search(text) {
  const url = '/api/search?text=' + encodeURIComponent(text || '');
  const res = await fetch(url);
  const data = await res.json();

  const intentDiv = document.getElementById('intent');
  intentDiv.innerHTML = '<pre>' + JSON.stringify(data.intent, null, 2) + '</pre>';

  const tb = document.querySelector('#tbl tbody');
  tb.innerHTML = '';
  for (const it of data.items) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="score">${it.__score}</td>
      <td>${it.company || ''}</td>
      <td>${it.title || ''}</td>
      <td>${it.field || ''}</td>
      <td>${it.location || ''}</td>
      <td>${it.url ? `<a href="${it.url}" target="_blank">ì›ë¬¸</a>` : ''}</td>
    `;
    tb.appendChild(tr);
  }
}

// ìŒì„± ì¸ì‹(Web Speech API)
const micBtn = document.getElementById('btnMic');
const searchBtn = document.getElementById('btnSearch');
const qEl = document.getElementById('q');

searchBtn.addEventListener('click', () => search(qEl.value));

micBtn.addEventListener('click', async () => {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { alert('ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.'); return; }
  const r = new SR();
  r.lang = 'ko-KR';
  r.interimResults = false;
  r.maxAlternatives = 1;
  r.onresult = (e) => {
    const text = e.results[0][0].transcript;
    qEl.value = text;
    search(text);
  };
  r.onerror = (e) => alert('ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ' + e.error);
  r.start();
});

// ================================
// README.md (ìš”ì•½)
// ================================
/*
1) Replitì—ì„œ Node.js í”„ë¡œì íŠ¸ ìƒì„± â†’ ìœ„ íŒŒì¼ êµ¬ì¡° ê·¸ëŒ€ë¡œ ì¶”ê°€
   - /data í´ë”ë¥¼ ë§Œë“¤ê³ , ì—…ë¡œë“œí•œ CSV/ì—‘ì…€(ì˜ˆ: ì œì¡°ì—….csv, ë§ˆì¼€íŒ….csv ë“±)ì„ ëª¨ë‘ ë„£ìœ¼ì„¸ìš”.
   - ê° íŒŒì¼ì—ëŠ” ìµœì†Œí•œ 'ë¶„ì•¼' ì»¬ëŸ¼ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. (íšŒì‚¬/ì§ë¬´/ì§€ì—­ ë“±ì€ ìˆìœ¼ë©´ ê°€ì‚°ì  ê³„ì‚°ì— í™œìš©)

2) ì„¤ì¹˜ & ì‹¤í–‰
   npm i
   npm start
   â†’ ë¸Œë¼ìš°ì €ì—ì„œ https://<repl-ì£¼ì†Œ> ì ‘ì†

3) ë™ì‘ ì›ë¦¬(í•µì‹¬)
   - ë°ì´í„° ë¡œë“œ ì‹œ, ê° ê³µê³ ì˜ 'ë¶„ì•¼' ë¬¸ìì—´ì„ í† í¬ë‚˜ì´ì¦ˆí•´ í•´ë‹¹ ë¶„ì•¼ì˜ ë™ì˜ì–´ ì‚¬ì „ì— ìë™ ì¶”ê°€(=ê°„ì´ í•™ìŠµ)
   - ì‚¬ìš©ìê°€ "ë‚˜ëŠ” ì‚¼ì„±ì—ì„œ ê¸°ê³„ ìˆ˜ë¦¬ ì¼ì„ í–ˆë‹¤" ê°™ì´ ë§í•˜ë©´ intent ì¶”ì¶œì—ì„œ 'ìˆ˜ë¦¬/ì •ë¹„' ì‹ í˜¸ë¥¼ ê°ì§€
   - /api/searchëŠ” intent.topField(ìµœìƒìœ„ ë¶„ì•¼ í›„ë³´)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í’€ì„ ë§Œë“¤ê³ ,
     scoreJob()ì—ì„œ ë‹¤ìŒ ê°€ì¤‘ì¹˜ë¡œ ì •ë ¬í•©ë‹ˆë‹¤:
       Â· ê°™ì€ ë¶„ì•¼ ì •í™• ì¼ì¹˜ +10, ë¶€ë¶„ ì¼ì¹˜ +6
       Â· ì‚¬ìš©ì ë¬¸ì¥ì— ìˆ˜ë¦¬ ì‹ í˜¸ê°€ ìˆìœ¼ë©´ ë¶„ì•¼/ì œëª©/ì„¤ëª…ì— ìˆ˜ë¦¬ ê´€ë ¨ì–´ê°€ ìˆì„ ë•Œ ê°ê° +8/+4/+3 (ì—†ì–´ë„ ë¶„ì•¼ì— ìˆìœ¼ë©´ +3)
       Â· ë¶„ì•¼ ë™ì˜ì–´ê°€ ì‚¬ìš©ì ë¬¸ì¥ì— ë“±ì¥í•  ë•Œ +1ì”© ëˆ„ì 
       Â· ì œëª©/ì„¤ëª…ì— ë¶„ì•¼ëª…ì´ í¬í•¨ë  ë•Œ +1ì”©

4) ë°”ë¡œ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ
   - ì…ë ¥: "ë‚˜ëŠ” ì‚¼ì„±ì—ì„œ ê¸°ê³„ ìˆ˜ë¦¬ ì¼ì„ í–ˆë‹¤"
   - ê¸°ëŒ€: 'ìˆ˜ë¦¬/ì •ë¹„/ìœ ì§€ë³´ìˆ˜/A/S' ë“±ì´ í¬í•¨ëœ 'ë¶„ì•¼'ì˜ ê³µê³ ê°€ ìµœìƒë‹¨ì— ë­í¬ë¨(íŠ¹íˆ ì œì¡°ì—…/ì„¤ë¹„/ì •ë¹„ ê´€ë ¨)

5) ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ
   - src/keywordMap.jsì˜ synonymMapì— ë¶„ì•¼ë³„ í‚¤ì›Œë“œë¥¼ ë” ë„£ê±°ë‚˜,
   - src/data-loader.jsì˜ STOP ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°ì •í•´ ìë™ í•™ìŠµ í’ˆì§ˆì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*/
